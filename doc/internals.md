# LK Internals
This document is an attempt to describe the internals of LK for ARM
architecture. It is aimed at people who are new to LK source. In some parts,
detailed explanation is given regarding to the architecture and instructions so
that people who are new to ARM assembly are not get lost. 

To understand LK, we need to have a big picture of how it is build and how the
key pieces are put in the right place (such as vector tables, interrupts,
etc.). Starting from the lower level, we are gradually move to upper level of
LK.

## The Build System
LK has its own build system written from scratch. It is highly modular which
allows LK to be easily ported to other architectures and platforms.

The tree is mainly structured as:

* project
* target
* platform
* arch

The core of the build system is `engine.mk`. Each module can set its own files
to compile along with its compiler flags. Additionally, each module can declare
dependencies which the build system resolves and build.

Starting at `project/<project>/rules.mk`, it defines where target is.
``target/<target>/rules.mk`` defines platform. Platform defines the
*architecture*, *memory base*, *memory size*, *linker to use*, *its own
sources* and *dependencies*. In this stage, we will start seeing `MODULE_DEPS`.
The build system recurses and solves its dependencies on another module. The
trick is that each module sets its own files to compiler, its own *CFLAGS*, etc
via `MODULE_*` vars, then includes `build/module.mk`. ``module.mk``generates
all the build rules for that module, then clears the vars.

Modules can define include paths. In the code, you will see headers like
`#include <platform/platform.h` or `#include <platform/vexpress-a9.h`. In order
to understand LK, we need to pay attention to include paths. It may seem that
`platform.h` and `vexpress-a9.h` reside in the same directory at first, but
they **do not**. `platform.h` is in *platform/* directory whereas
`vexpress-a9.h` is in *platform/vexpress-a9/include/platform/* directory.
`platform/vexpress-a9/rules.mk` extends the `GLOBAL_INCLUDES` variable to
include its local path, so we are able to use platform specific headers.

*TODO: add config.h generation, compiler includes config.h automatically, which
is generated by build system. debug variables.*

The order of the build and CFLAGS can be seen by setting `NOECHO`, which may
help to understand the build system. Create `local.mk` file, put the following
in it, and run `make`. The best way to understand what build system does is to
read its output and play with it.


	PROJECT := vexpress-a9-test
	NOECHO :=

### Creating Image
After a successful build, we get a working kernel in
`build-<PROJECT_NAME>/lk.elf`. Before delving into the code, it is helpful to
take a look at linker script to see which goes where.

There are two linker scripts: `system-onesegment.ld` and `system-twosegment.ld`
for ARM architecture. These linker scripts are in `arch/arm/` directory. Each
platform *(platform/NAME/rules.mk)* defines which linker script to use with
`LINKER_SCRIPT` variable. After the project compiles, this script is used to
take the parts in object code and place them accordingly, resulting in
the final kernel image.

Now let's have a look at how ARM boots and how the key pieces are created.

## Booting
This part gives a general overview of how ARM is booted in LK.

The first code to be run in the hardware is defined in `arch/arm/arm/start.S`
file. In summary, `start.S` creates a vector table, a stack, changes stack
pointer of each mode, and jumps to `lk_main` (which is defined in
*top/main.c*).

### The Vector Table
The Vector Table is used to define the routines to be called when an exception
occurs. In ARM, the vector table simply contains branch (b) instructions to the
actual interrupt handler. The Vector Table is defined in the beginning of
`start.S` and it is put in .text.boot section.

```asm
	.section ".text.boot"
	.globl _start
	_start:
        	b       platform_reset
        	b       arm_undefined
        	b       arm_syscall
        	b       arm_prefetch_abort
        	b       arm_data_abort
        	b       arm_reserved
        	b       arm_irq
        	b       arm_fiq
```

These routines except `platform_reset` are defined in `arch/arm/arm/exceptions.S` file.

### Exceptions
Each routine in the vector table above is defined in `exceptions.S` with
FUNCTION macro. This macro is defined in `include/asm.h` file.

The routines `save` and `saveall` create a stack frame as defined in
`arch/arm/include/arch/arm.h`, pass this frame to higher-level C function, and
jump to it. These higher level functions are defined in
`arch/arm/arm/faults.c`.

* **save**: creates `struct arm_iframe`
* **saveall**: creates `struct arm_fault_frame`
* **saveall_offset**: subtracts an offset from link register then call `saveall`

We have `saveall_offset` function because of the fact that (PC +
exception-dependent offset) is saved in the link register when an exception
occurs. To get the real PC value, we need to subtract an offset. Some
exceptions such as `arm_undefined` and `arm_syscall` do not need it so
`saveall` is called directly.  see **B1.6.3 Exception** Entry in **ARM ARM
DBI0406B_10_10** for further reference.

Let's look at how a stack frame is created in `saveall`. This part explains
some ARM instruction set for ARM newbies. You can skip it if you can understand
the routine.

```
		.macro saveall, mode
        /*
         * This routine creates "struct arm_fault_frame" as defined in
         * arch/arm/include/arch/arm.h.
         */

        /*
         * Save SPSR and r14 onto our stack
         *
         * SRS means Store Return State onto stack. DB (Decrement Before) is an
         * addressing mode.  Since we use full decreasing stack, meaning that stack
         * pointer points to the top of the stack which has a value in it, we need
         * to decrement the stack first, then write the value.
         *
         * SRS stores the lr and the SPSR of the current mode, at the address
         * contained in SP of the mode specified by mode.
         *
         * Our stack looks like this after srsdb instruction:
         * <high>
         * ...
         * SPSR
         * LR  <- stack pointer
         * ...
         * <low>
         *
         * NOTE: Before saveall routine is called, an offset is already subtracted
         * from lr. Thus, lr actually contains an address to return to without
         * requiring to subtraction. Please look at saveall_offset routine. Some
         * exceptions such as arm_undefined and arm_syscall do not require
         * subtraction and saveall is called directly.
         */
        srsdb   \mode! 
        
         /*
         * Save all regs and lr to keep the stack aligned
         *
         * After pushing the registers on stack, our stack looks like this:
         *
         * <high>
         * ...
         * SPSR
         * LR
         * r14
         * r12
         * r11
         * ...
         * r0  <- stack pointer
         * ...
         * <low>
         *
         */
        push    { r0-r12, r14 }
        
        /*
         * Make a room for 2 registers in the stack. Now stack pointer points an
         * empty location. (Of course there would be data in this area but let's
         * call it empty for our use)
         *
         * <high>
         * ...
         * r0
         * EMPTY
         * EMPTY <- stack pointer
         * ...
         * <low>
         */
        sub             sp, #8
        
        /*
         * Save user space lr (r14) and user space sp (r13) onto the stack.
         *
         * Use stmia (Store Multiple Increment After) instruction to put r13 and
         * r14 onto the stack. Since SP points to empty location, we put two
         * registers one after another. r13 register is written first, then r14 is
         * written afterwards. In ARM, lower numbered registers are put in the
         * lower address. Remember that SP is not updated after this
         * operation. ^ identifier makes stmia access r13 and r14 from user space
         * instead of banked registers. So, finally the stack looks like this:
         *
         * <high>
         * ...
         * SPSR
         * LR
         * r14
         * r12
         * r11
         * ...
         * r0
         * r14
         * r13  <- stack pointer
         * ...
         * <low>
         *
         */
        stmia   sp, { r13, r14 }^
```

With this stack frame, exceptions move sp to r0 and call higher level C code.
In ARM calling convention, r0 contains the first parameter to the functions. 

```asm
	FUNCTION(arm_undefined)
        saveall #0x1b
        mov             r0, sp

        /* void arm_undefined_handler(struct arm_fault_frame *frame) */
        bl              arm_undefined_handler
```

Since our stack pointer now points to r13, which is at the lower address, we
can access this frame incrementally as defined in `arm.h`. 

```c
	struct arm_fault_frame {
		   uint32_t usp;    // user stack pointer
		   uint32_t ulr;    // user link register
		   uint32_t r[13];
		   uint32_t lr;
		   uint32_t pc;
		   uint32_t spsr;
	};
```

#### IRQ

In `arm_irq`, `arm_iframe` is created and it jumps to `platform_irq` function.
Each platform handles IRQs differently so the definition of `platform_irq` will
vary from platform to platform. It is usually defined in `interrupts.c` file in
the directory of the specific platform.

### Registering Interrupt Handler

